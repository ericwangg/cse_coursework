
class Signals:
    def __init__(self):
        self.reset()

    def reset(self):
        #  already generated
        self.PC = self.PC_4 = self.instruction = 0

        # signals that are extracted from instruction
        self.opcode = self.funct = self.rs = self.rt = self.rd = self.immediate = 0

        # generated by the main control from opcode
        self.RegDst = self.Jump = self.Branch = self.MemRead = self.MemtoReg = self.ALUOp = self.MemWrite = self.ALUSrc = self.RegWrite = 0

        # generated by sign extend
        self.Sign_extended_immediate = 0

        # generated by ALU control 
        self.ALU_operation = 0

        # calculated address
        self.Branch_address = self.Jump_address = 0

        # Write_register can be decided early
        self.Write_register = self.Write_data = 0

        # Register file read data
        # read_register_1 = rs  read_register_2 = rt
        self.RF_read_data_1 = self.RF_read_data_2 = 0

        # ALU
        # ALU_input_1 = RF_read_data_1
        self.ALU_input_2 = self.ALU_result = self.Zero = 0
        # for software only. You need to move value to ALU_result and ALU_Zero.
        self.ALU_returned_value = [0, 0]

        # D_Mem
        # D_Mem address = ALU_result
        self.MEM_read_data = 0

        # PC_branch is the output of the MUX controlled by branch
        self.PCSrc = self.PC_branch = 0

        # PC that will be used to fetch instruction in the next cycle
        self.PC_new = 0

        # Add more signals here
