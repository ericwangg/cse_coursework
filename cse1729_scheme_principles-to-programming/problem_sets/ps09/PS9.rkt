"Problem Set 9 - Eric Wang"

"1A - Clock"
(define (make-clock hrs mins)
  (let ((clck (+ (* hrs 60) mins)))
    (define (tick)
      (begin
        (set! clck (+ clck 1))))
    (define (time)
      (let ((hrs (floor (/ clck 60)))
            (mins (modulo clck 60)))
        (cond ((and (< hrs 12) (< mins 10)) (string-append (number->string hrs) ":0" (number->string mins) " AM\n"))
              ((and (< hrs 12) (>= mins 10)) (string-append (number->string hrs) ":" (number->string mins) " AM\n"))
              ((and (= hrs 12) (< mins 10)) (string-append (number->string hrs) ":0" (number->string mins) " PM\n"))
              ((and (= hrs 12) (>= mins 10)) (string-append (number->string hrs) ":0" (number->string mins) " PM\n"))
              ((and (> hrs 12) (< mins 10)) (string-append (number->string (- hrs 12)) ":0" (number->string mins) " PM"))
              ((and (> hrs 12) (>= mins 10)) (string-append (number->string (- hrs 12)) ":0" (number->string mins) " PM")))))
    (define (military)
      (let ((hrs (floor (/ clck 60)))
            (mins (modulo clck 60)))
        (cond ((and (<= hrs 9) (< mins 10)) (string-append "0" (number->string hrs) ":0" (number->string mins) "\n"))
              ((and (<= hrs 9) (>= mins 10)) (string-append "0" (number->string hrs) ":" (number->string mins) "\n"))
              ((and (> hrs 9) (< mins 10)) (string-append (number->string hrs) ":0" (number->string mins) "\n"))
              ((and (> hrs 9) (>= mins 10)) (string-append (number->string hrs) ":" (number->string mins) "\n"))
              ((and (> hrs 24)))
              )))  
    (lambda (clock-work)
      (cond ((eq? clock-work 'time) time)
            ((eq? clock-work 'tick) tick)
            ((eq? clock-work 'military) military)))))


                 
"2 - Evluation of Postfix Expressions"
(define (make-stack)
  (let ((stack '() ))
    (define (is-empty?)
      (null? stack))
    (define (push x)
      (set! stack (cons x stack)))
    (define (top)
      (car stack))
    (define (pop)
      (let ((value (car stack)))
        (begin (set! stack (cdr stack))
               value)))
    (lambda (meth-name) 
      (cond ((eq? meth-name 'empty) is-empty?)
            ((eq? meth-name 'push) push)
            ((eq? meth-name 'top) top)
            ((eq? meth-name 'pop) pop)))))

(define (make-tree value left right)
  (list value left right))
(define (value T) (car T))
(define (left T) (cadr T))
(define (right T) (caddr T))

(define (eval-postfix p)
  (let ((postfix p)
        (ops (make-stack)))
    (define (process-operation op)
      (cond ((eq? op #\+) ((ops 'push) (+ ((ops 'pop))
                                          ((ops 'pop))
                                          )))
            ((eq? op #\-) ((ops 'push) (let ((op2 ((ops 'pop)))
                                             (op1 ((ops 'pop))))
                                         (- op1 op2))))
            ((eq? op #\*) ((ops 'push) (* ((ops 'pop))
                                          ((ops 'pop))
                                          )))
            ((eq? op #\/) ((ops 'push) (let ((op2 ((ops 'pop)))
                                             (op1 ((ops 'pop))))
                                         (/ op1 op2))))
            ((eq? op #\^) ((ops 'push) (let ((op2 ((ops 'pop)))
                                             (op1 ((ops 'pop))))
                                         (expt op1 op2))))))
    (define (process-exp)
      (cond ((null? postfix) ((ops 'top)))
            ((number? (car postfix)) (begin ((ops 'push) (car postfix))
                                            (set! postfix (cdr postfix))
                                            (process-exp)))
            (else (begin (process-operation (car postfix))
                         (set! postfix (cdr postfix))
                         (process-exp)))))
    (begin (process-operation p) (process-exp)
           ((ops 'pop)))))

(eval-postfix '(69))
(eval-postfix (list 23 25 (string-ref (symbol->string '+) 0)))


"3 - Depth First Search of Binary Trees"
(define (dfs T)
  (let ((stack (make-stack)))
    (define (help L)
      (if ((stack 'empty))
          (reverse L)
          (let ((node ((stack 'pop))))
            (begin (if (not (null? (right node)))
                       ((stack 'push) (right node)))
                   (if (not (null? (left node)))
                       ((stack 'push) (left node)))
                   (help (cons (value node) L))))))
    (begin ((stack 'push) T)
           (help '() ))))

(dfs '(a (b () () ) (c () () )))
(dfs '(a () () ()))

"4 - Breadth First Search of Binary Trees"
(define (make-queue)
  (let ((head '())
        (tail '()))
    (define (value n) (car n))
    (define (next n) (cdr n))
    (define (empty?) (null? head))
    (define (front) (value head))
    (define (enqueue x)
      (let ((new-node (cons x '())))
        (begin
          (if (empty?)
              (set! head new-node)
              (set-cdr! tail new-node))
          (set! tail new-node))))
    (define (dequeue)
      (let ((return (value head)))
        (if (eq? head tail)
            (begin (set! head '())
                   (set! tail '())
                   return)
            (begin (set! head (next head))
                   return))))
    (define (dispatcher method)
      (cond ((eq? method 'empty) empty?)
            ((eq? method 'enqueue) enqueue)
            ((eq? method 'dequeue) dequeue)
            ((eq? method 'front) front)))
   dispatcher))

(define (bfs T)
  (let ((q (make-queue)))
    (define (help L) (if ((q 'empty))
                         (reverse L)
                         (let ((node ((q 'dequeue))))
                           (begin (if (not (null? (left node)))
                                      ((q 'enqueue) (left node)))
                                  (if (not (null? (right node)))
                                      ((q 'enqueue) (right node)))
                                  (help (cons (value node) L))))))
    (begin ((q 'enqueue) T)
           (help '()))))

(bfs '(a (b () () ) (c () () )))
(bfs '(a () () ()))